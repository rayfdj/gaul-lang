# Gaul Language Reference for AI Coding Agents

> Gaul is a dynamically-typed, interpreted language with spaced identifiers, custom keywords, and fuzzy equality. This document contains everything needed to write idiomatic Gaul code.

## Critical Differences from Mainstream Languages

When generating Gaul code, you MUST follow these conventions:

1. **Use spaced identifiers** - Write `My Variable` not `myVariable` or `my_variable`
2. **Capitalize words** - Convention is `Title Case With Spaces` for identifiers
3. **Use `&&`/`||` for logic, `!` for negation** - These are symbol operators, same as most languages
4. **`&&`/`||` don't need parenthesization** - Unlike the old keyword operators, `A > 0 && B < 10` works fine. Parens still improve readability for complex expressions.
5. **No semicolons** - Expressions are newline/punctuation-delimited
6. **Expression-based if** - `if` returns a value: `let X = if(cond) { a } else { b }`
7. **Parentheses required** - `if(cond)`, `while(cond)`, `for(x : collection)`
8. **Colon in for loops** - `for(Item : Array)` not `for Item in Array`
9. **Method access with `.get()`** - Arrays use `Arr.get(0)` not `Arr[0]`
10. **Parenthesize multiline chains** - Wrap method chains spanning multiple lines in `()` or the parser won't see continuations

---

## Variables

```gaul
let Immutable Value = 42           // Cannot be reassigned
var Mutable Counter = 0            // Can be reassigned
Mutable Counter = Mutable Counter + 1
```

Identifiers can contain spaces and terminate at operators, punctuation, or newlines.

---

## Data Types

```gaul
// Numbers (all floats internally)
let Integer = 42
let Float = 3.14159
let With Separators = 1_000_000    // Readability separators
let Hex = 0xFF                     // 255
let Binary = 0b1010                // 10
let Octal = 0o77                   // 63

// Strings
let Greeting = "Hello, World!"
let Unicode = "Bonjour"

// Escape sequences in strings
let With Newline = "line1\nline2"
let With Tab = "col1\tcol2"
let With Quote = "she said \"hi\""
let With Backslash = "C:\\Users\\file.txt"
let With CR = "old\rstyle"
// Supported: \n \t \r \\ \"
// Invalid escapes (e.g. \a, \z) produce a scanner error

// Booleans
let Yes = true
let No = false

// Arrays (heterogeneous)
let Mixed = [1, "two", true, [3, 4]]
let Matrix = [[1, 2], [3, 4]]

// Maps (key-value dictionaries)
let Empty = [:]                              // Empty map
let Person = ["name": "Alice", "age": 30]    // String keys
let Grid = [0: "origin", 1: "right"]         // Numeric keys
let Mixed Map = ["key": 1, 42: "val", true: "yes"]  // Mixed key types
// Keys can be: Str, Num, Bool, null. Arrays/functions/maps cannot be keys.

// Null
let Nothing = null
```

---

## Operators

### Arithmetic
```gaul
5 + 3      // 8
5 - 3      // 2
5 * 3      // 15
5 / 3      // 1.666...
5 % 3      // 2 (Euclidean modulo — same as 5.mod(3))
5.pow(3)   // 125
min(3, 5)  // 3
max(3, 5)  // 5
```

### Comparison
```gaul
a == b     // Strict equality
a != b     // Strict inequality
a < b
a <= b
a > b
a >= b
```

### Jam Karet (Fuzzy Equality) - UNIQUE TO GAUL
```gaul
a ~= b     // Approximate equality

// For numbers: within 5% tolerance (default)
100 ~= 104          // true (4% difference)
100 ~= 110          // false (10% difference)
0.1 + 0.2 ~= 0.3    // true (solves float imprecision!)

// For strings: Levenshtein distance tolerance (default 20%)
"hello" ~= "helo"   // true (1 edit)
"hello" ~= "world"  // false (too different)
```

### Logical (`&&`, `||`, `!`)

```gaul
true && false       // false
true || false       // true
!true               // false (use ! for negation, not "not")

// These just work - no special parenthesization needed
A > 0 && B < 10
X == 1 || Y == 2
Foo && Bar
(A > 0 && B < 10) || C == 0
!(Is Valid)         // Negation with !
```

### String Concatenation
```gaul
"Hello, " + "World!"  // "Hello, World!"
"Value: " + 42        // "Value: 42" (auto-converts)
```

### Subscript Access
```gaul
// Array: read and write by index
Arr[0]           // read first element
Arr[i]           // read by variable index
Arr[i + 1]       // read by expression
Arr[0] = 99      // write (out-of-bounds → runtime error)
Arr[i] += 1      // compound assignment works too

// Map: read and write by key
M["name"]        // read (missing key → null, not an error)
M["name"] = "x"  // write (creates key if missing)
M[var key]       // dynamic key — any expression works as key

// String: read only (strings are immutable)
"hello"[0]       // "h"
S[i]             // character at index i (out-of-bounds → runtime error)
```

### Compound Assignment
```gaul
var x = 10
x += 5     // x is now 15 (same as x = x + 5)
x -= 3     // x is now 12
x *= 2     // x is now 24
x /= 4     // x is now 6

// Works with spaced identifiers too
var total distance = 0
var step size = 5
total distance += step size   // total distance is now 5
```

### Bitwise
```gaul
5 & 3      // 1 (AND)
5 | 3      // 7 (OR)
5 ^ 3      // 6 (XOR)
1 << 3     // 8 (left shift)
8 >> 2     // 2 (right shift)
~5         // -6 (bitwise NOT)
// All operate on numbers, truncating to integers internally
```

---

## Control Flow

### If/Else (Expression-Based)
```gaul
// If is an EXPRESSION - it returns a value
let Grade = if(Score >= 90) {
    "A"
} else {
    if(Score >= 80) { "B" } else { "C" }
}

// Can use inline for simple cases
let Max = if(A > B) { A } else { B }

// As statement (return value ignored)
if(Debug Mode) {
    println("Debug info")
}
```

### While Loop
```gaul
var I = 0
while(I < 10) {
    println(I)
    I = I + 1
}
```

### For Loop (Three Forms)
```gaul
// Iterating over array
for(Item : My Array) {
    println(Item)
}

// Iterating over range (exclusive end)
for(I : 0..10) {
    println(I)  // 0, 1, 2, ... 9
}

// Iterating over map (iterates over KEYS)
let Scores = ["Alice": 95, "Bob": 87]
for(Name : Scores) {
    println(Name)               // "Alice", "Bob"
    println(Scores.get(Name))   // 95, 87
}

// Ranges must be converted to array for methods
let Indices = (0..10).to_array()
```

### Break and Continue
```gaul
for(I : 0..100) {
    if(I == 50) { break }
    if(I.mod(2) == 0) { continue }
    println(I)
}
```

---

## Functions

### Definition and Calls
```gaul
fn Calculate Total(Base Price, Tax Rate) {
    Base Price * (1 + Tax Rate)
}

let Price = Calculate Total(100, 0.08)
```

### Return Statement
```gaul
fn Find First Match(Items, Target) {
    for(Item : Items) {
        if(Item == Target) {
            return Item  // Early return
        }
    }
    return null
}
```

### Implicit Return
```gaul
// Last expression is returned automatically
fn Square(X) {
    X * X
}
```

### Anonymous Functions (Lambdas)
```gaul
let Double = fn(X) { X * 2 }
Double(5)  // 10

// Common with higher-order functions
Numbers.map(fn(X) { X * 2 })
Numbers.filter(fn(X) { X > 0 })
```

### Self-Referencing Variables
```gaul
// let/var initializers can reference their own name.
// This is useful for recursive lambdas without fn declarations.
let Factorial = fn(N, Acc) {
    if(N <= 1) { Acc }
    else { Factorial(N - 1, N * Acc) }
}
Factorial(10, 1)  // 3628800
```

### Tail Call Optimization
```gaul
// Gaul optimizes tail-position calls so recursive functions
// don't overflow the stack. Works with fn declarations and lambdas.
fn Countdown(N) {
    if(N <= 0) { "done" }
    else { Countdown(N - 1) }   // tail call, no stack growth
}
Countdown(1000000)  // "done", no stack overflow

// Accumulator pattern with TCO
fn Sum(N, Acc) {
    if(N <= 0) { Acc }
    else { Sum(N - 1, Acc + N) }  // tail call
}
Sum(1000000, 0)  // 500000500000
```

### Closures
```gaul
fn Make Counter() {
    var Count = 0
    fn Increment() {
        Count = Count + 1
        Count
    }
    return Increment
}

let Counter = Make Counter()
Counter()  // 1
Counter()  // 2
```

---

## Standard Library Methods

### String Methods
```gaul
let S = "Hello, World!"

S.len()                  // 13
S.chars()                // ["H", "e", "l", "l", "o", ...]
S.char_at(0)             // "H"
S.substring(0, 5)        // "Hello"
S.split(", ")            // ["Hello", "World!"]
S.contains("World")      // true
S.trim()                 // Removes leading/trailing whitespace
S.to_num()               // Parse to number (or nil if invalid)
S.lines()                // Split by newlines
S.replace("World", "Gaul")  // "Hello, Gaul!" (replaces all occurrences)
S.index_of("World")      // 7 (char index, or -1 if not found)
S.to_upper()             // "HELLO, WORLD!"
S.to_lower()             // "hello, world!"
S.repeat(2)              // "Hello, World!Hello, World!"
S.starts_with("Hello")   // true
S.ends_with("!")          // true
```

### Array Methods
```gaul
let Arr = [3, 1, 4, 1, 5, 9]

// Access
Arr.len()                // 6
Arr[0]                   // 3  (subscript read)
Arr.first()              // 3
Arr.last()               // 9

// Modification (mutates in place)
Arr.push(2)              // Appends 2
Arr.pop()                // Removes and returns last element (null if empty)
Arr[0] = 99              // Subscript write (same as Arr.set(0, 99))
Arr.set(0, 99)           // Sets index 0 to 99
Arr.remove(0)            // Removes and returns element at index (shifts rest left)

// Aggregation
Arr.sum()                // 23
Arr.min()                // 1
Arr.max()                // 9

// Transformation (returns new array)
Arr.sort()               // [1, 1, 3, 4, 5, 9]
Arr.sort_by(fn(A, B) { A - B })   // custom comparator (negative = A first)
Arr.sort_by_key(fn(X) { X.abs() }) // sort by extracted key (Num or Str)
Arr.reverse()            // [9, 5, 1, 4, 1, 3]
Arr.join("-")            // "3-1-4-1-5-9"
Arr.slice(1, 3)          // [1, 4] (from start to end, end optional)

// Query
Arr.is_empty()           // false

// Search
Arr.contains(5)          // true
Arr.index_of(4)          // 2 (first index, or -1 if not found)
Arr.find(fn(x) { x > 3 })  // 4 (first match, or null if none)

// Enumeration
Arr.enumerate()          // [[0, 3], [1, 1], [2, 4], ...] — pairs of [index, value]
for(Pair : Arr.enumerate()) {
    let I = Pair.get(0)
    let Item = Pair.get(1)
}
```

### Map Methods
```gaul
let M = ["name": "Alice", "age": 30]

// Access
M["name"]                    // "Alice"  (subscript read)
M["missing"]                 // null (no error for missing keys!)
M.get("name")                // "Alice"  (method form)
M.get_or("missing", "default")  // "default" (returns default if key absent)

// Modification (mutates in place)
M["email"] = "a@b.com"      // Subscript write (insert or overwrite)
M.set("email", "a@b.com")   // Insert or overwrite, returns null
M.remove("email")            // Returns removed value, or null if missing

// Queries
M.has("name")                // true
M.len()                      // 2
M.is_empty()                 // false

// Bulk access (returns arrays)
M.keys()                     // ["name", "age"]
M.values()                   // ["Alice", 30]
M.entries()                  // [["name", "Alice"], ["age", 30]]
```

### Functional Methods (Most Important!)
```gaul
let Numbers = [1, 2, 3, 4, 5]

// Map: transform each element
let Doubled = Numbers.map(fn(X) { X * 2 })
// [2, 4, 6, 8, 10]

// Filter: keep matching elements
let Evens = Numbers.filter(fn(X) { X.mod(2) == 0 })
// [2, 4]

// Reduce: accumulate to single value
let Sum = Numbers.reduce(0, fn(Acc, X) { Acc + X })
// 15

// Chaining (IDIOMATIC GAUL)
// IMPORTANT: Wrap multiline chains in parentheses!
let Result = (Numbers
    .filter(fn(X) { X.mod(2) == 0 })
    .map(fn(X) { X * X })
    .sum())
// 20

// Single-line chains don't need outer parens
let Sum = Numbers.filter(fn(X) { X > 0 }).sum()
```

### Number Methods
```gaul
let N = -42.7

N.to_str()               // "-42.7"
N.abs()                  // 42.7
N.floor()                // -43
N.ceil()                 // -42
N.round()                // -43
N.sqrt()                 // NaN (negative)
42.mod(5)                // 2 (modulo)
42.floor_div(5)          // 8 (integer division)
42.pow(2)                // 1764
```

### Bool Methods
```gaul
true.to_str()            // "true"
false.to_str()           // "false"
```

### Range Methods
```gaul
let R = 0..10

R.from()                 // 0 (start of the range)
R.until()                // 10 (exclusive end of the range)
R.to_array()             // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
```

---

## Modules

Split code across files with `export` and `import`.

```gaul
// math.gaul
export fn double(x) { x * 2 }
export let Pi = 3.14159
export var Counter = 0
```

```gaul
// main.gaul
import { double, Pi } from "math.gaul"
println(double(21))   // 42
println(Pi)           // 3.14159
```

### Rules

- **`export let`, `export var`, `export fn`** — these three forms are valid. Exporting a bare expression is a parse error.
- **Named imports only**: `import { Name1, Name2 } from "path.gaul"`. No glob imports.
- **Path resolution**: relative to the importing file's directory (not the process working directory). The REPL falls back to CWD.
- **Module cache**: each file is scanned/parsed/executed at most once per run; subsequent imports of the same file return the cached exports.
- **Circular imports**: detected at runtime and reported as an error.
- **Imported names are immutable** (like `let`). You cannot reassign them.
- **Custom keywords** apply here too: `"import"`, `"export"`, and `"from"` can all be remapped in your keywords JSON.

### Examples

```gaul
// lib/utils.gaul
export fn clamp(V, Lo, Hi) {
    if(V < Lo) { Lo } else { if(V > Hi) { Hi } else { V } }
}

export let Max Int = 1000000
```

```gaul
// app.gaul
import { clamp, Max Int } from "lib/utils.gaul"

let Safe Value = clamp(9999, 0, Max Int)
println(Safe Value)   // 9999
```

---

## File I/O and Stdin

```gaul
let Content = read_file("data.txt")   // read entire file as string
let Lines = Content.lines()

for(Line : Lines) {
    println(Line.trim())
}
```

```gaul
let All = read_stdin()       // read all of stdin as a string (e.g. piped input)
let Line = read_line()       // read one line from stdin (trailing \r\n stripped)
```

`read_stdin()` and `read_line()` work on all platforms (Linux, macOS, Windows).
Use `.lines()` on the result of `read_stdin()` to iterate line by line.

```gaul
// Process piped input: cat data.txt | gaul solve.gaul
let Input = read_stdin()
for(Line : Input.lines()) {
    println(Line.trim())
}

// Interactive prompts
let Name = read_line()
println(format("Hello, {}!", Name))
```

---

## Output

```gaul
println("Hello")         // Print with newline
println(42)              // Numbers auto-convert
println([1, 2, 3])       // Arrays print as [1, 2, 3]
print("Loading...")      // Print without newline (flushes stdout)
print(".")
println(" done!")        // Loading... done!
```

---

## String Interpolation

`format(template, arg1, arg2, ...)` — replace `{}` placeholders with values.

```gaul
format("hello {}", "gaul")          // "hello gaul"
format("score: {}", 42)             // "score: 42"
format("{} + {} = {}", 1, 2, 3)     // "1 + 2 = 3"
format("done: {}", true)            // "done: true"

var name = "world"
format("hello, {}!", name)          // "hello, world!"
```

- First argument must be a string (the template).
- Number of `{}` must match the number of remaining arguments — mismatch is a runtime error.
- Any value type is accepted as a fill argument; it's converted to its string representation.
- For building strings in a loop, prefer `[...].join(sep)` over repeated string concatenation.

---

## Idiomatic Gaul Patterns

### Pattern 1: Functional Pipelines
```gaul
// PREFER this (functional, chainable)
let Valid Entries = (Input.lines()
    .map(fn(Line) { Line.trim() })
    .filter(fn(Line) { Line.len() > 0 })
    .map(fn(Line) { Parse Entry(Line) })
    .filter(fn(Entry) { Entry != null }))

// AVOID this (imperative, verbose)
var Valid Entries = []
for(Line : Input.lines()) {
    let Trimmed = Line.trim()
    if(Trimmed.len() > 0) {
        let Entry = Parse Entry(Trimmed)
        if(Entry != nil) {
            Valid Entries.push(Entry)
        }
    }
}
```

### Pattern 2: Expression-Based Results
```gaul
// PREFER: if as expression
let Status = if(Count > 0) { "found" } else { "empty" }

// PREFER: blocks return last expression
fn Categorize(Value) {
    if(Value < 0) {
        "negative"
    } else {
        if(Value == 0) { "zero" } else { "positive" }
    }
}
```

### Pattern 3: Descriptive Spaced Names
```gaul
// PREFER: reads like English
fn Calculate Tax Amount(Gross Income, Tax Rate, Deductions) {
    let Taxable Income = Gross Income - Deductions
    Taxable Income * Tax Rate
}

// AVOID: camelCase or snake_case
fn calculateTaxAmount(grossIncome, taxRate, deductions) { ... }
fn calculate_tax_amount(gross_income, tax_rate, deductions) { ... }
```

### Pattern 4: Grid/Matrix Access Helper
```gaul
fn Get Cell(Grid, Row, Col) {
    let Rows = Grid.len()
    let Cols = Grid.get(0).len()
    if(Row >= 0 && Row < Rows && Col >= 0 && Col < Cols) {
        Grid.get(Row).get(Col)
    } else {
        null  // or default value
    }
}
```

### Pattern 5: Generating All Positions
```gaul
fn All Positions(Grid) {
    let Rows = Grid.len()
    let Cols = Grid.get(0).len()
    (0..Rows).to_array().reduce([], fn(Acc, Row) {
        let Row Positions = (0..Cols).to_array().map(fn(Col) { [Row, Col] })
        Row Positions.reduce(Acc, fn(A, Pos) {
            A.push(Pos)
            A
        })
    })
}
```

### Pattern 6: Parsing Structured Input
```gaul
fn Parse Numbers From Line(Line) {
    (Line.split(" ")
        .map(fn(S) { S.trim() })
        .filter(fn(S) { S.len() > 0 })
        .map(fn(S) { S.to_num() }))
}

fn Parse Input(Input) {
    (Input.lines()
        .filter(fn(L) { L.trim().len() > 0 })
        .map(fn(L) { Parse Numbers From Line(L) }))
}
```

### Pattern 7: Frequency Counting with Maps
```gaul
// Count occurrences of each item
let Words = ["apple", "banana", "apple", "cherry", "banana", "apple"]
let Counts = [:]
for(Word : Words) {
    Counts.set(Word, Counts.get_or(Word, 0) + 1)
}
// Counts = ["apple": 3, "banana": 2, "cherry": 1]
```

### Pattern 8: Visited Set / Memoization with Maps
```gaul
// Track visited items (O(1) lookup instead of O(n) array scan)
let Seen = [:]
for(Item : Items) {
    if(!Seen.has(Item)) {
        Seen.set(Item, true)
        // process Item...
    }
}

// Memoization
let Cache = [:]
fn Fibonacci(N) {
    if(N <= 1) { return N }
    if(Cache.has(N)) { return Cache.get(N) }
    let Result = Fibonacci(N - 1) + Fibonacci(N - 2)
    Cache.set(N, Result)
    Result
}
```

### Pattern 9: Grouping with Maps
```gaul
// Group items by category
let Items = [["fruit", "apple"], ["veggie", "carrot"], ["fruit", "banana"]]
let Groups = [:]
for(Item : Items) {
    let Category = Item.get(0)
    let Name = Item.get(1)
    if(!Groups.has(Category)) {
        Groups.set(Category, [])
    }
    Groups.get(Category).push(Name)
}
// Groups = ["fruit": ["apple", "banana"], "veggie": ["carrot"]]
```

### Pattern 10: Accumulating with Reduce
```gaul
// Sum with initial value
let Total = Items.reduce(0, fn(Acc, Item) { Acc + Item.value })

// Building arrays
let Flattened = Nested.reduce([], fn(Acc, Arr) {
    for(Item : Arr) { Acc.push(Item) }
    Acc
})

// Finding maximum
let Max Item = Items.reduce(Items.first(), fn(Best, Item) {
    if(Item.score > Best.score) { Item } else { Best }
})
```

---

## Common Mistakes to Avoid

```gaul
// WRONG: Using single & | for logic (those are bitwise!)
if(A & B) { }                   // & is bitwise AND, use: if(A && B)
if(A | B) { }                   // | is bitwise OR, use: if(A || B)

// WRONG: Using % for modulo
let R = 10 % 3                  // Use: 10 % 3 or 10.mod(3) (both work now)

// WRONG: Missing parentheses in control flow
if Condition { }                // Use: if(Condition) { }
for X : Array { }               // Use: for(X : Array) { }

// WRONG: Using semicolons
let X = 5;                      // Use: let X = 5

// WRONG: camelCase/snake_case
let myVariable = 5              // Use: let My Variable = 5
fn do_something() { }           // Use: fn Do Something() { }

// WRONG: in-keyword for iteration
for X in Array { }              // Use: for(X : Array) { }

// WRONG: Multiline method chains without parentheses
let Result = Items
    .filter(fn(X) { X > 0 })
    .map(fn(X) { X * 2 })       // BROKEN: Parser doesn't see continuation
// CORRECT: Wrap in parentheses
let Result = (Items
    .filter(fn(X) { X > 0 })
    .map(fn(X) { X * 2 }))      // Works: Parens group the expression
```

---

## Custom Keywords (Localization)

Gaul supports programming in any language via JSON keyword mapping:

```bash
gaul-lang script.gaul --keywords français.json
```

Example `français.json`:
```json
{
  "function": "sortilege",
  "return": "renvoie",
  "if": "si",
  "else": "sinon",
  "let": "soit",
  "var": "variable",
  "while": "tantque",
  "for": "pour",
  "true": "vrai",
  "false": "faux",
  "break": "arreter",
  "continue": "continuer"
}
```

Then write:
```gaul
sortilege Fibonacci(N) {
    si(N <= 1) { renvoie N }
    renvoie Fibonacci(N - 1) + Fibonacci(N - 2)
}
```

---

## Complete Example: Advent of Code Style

```gaul
let Input = read_file("input.txt")

fn Parse Grid(Lines) {
    (Lines
        .map(fn(Line) { Line.trim() })
        .filter(fn(Line) { Line.len() > 0 })
        .map(fn(Line) { Line.chars() }))
}

fn Get Cell(Grid, Row, Col) {
    let Rows = Grid.len()
    let Cols = Grid.get(0).len()
    if(Row >= 0 && Row < Rows && Col >= 0 && Col < Cols) {
        Grid.get(Row).get(Col)
    } else {
        "."
    }
}

fn Count Neighbors(Grid, Row, Col, Target) {
    let Offsets = [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1]]
    (Offsets
        .map(fn(O) { Get Cell(Grid, Row + O.get(0), Col + O.get(1)) })
        .filter(fn(C) { C == Target })
        .len())
}

fn Solve Part 1(Input) {
    let Grid = Parse Grid(Input.lines())
    var Count = 0
    for(Row : 0..Grid.len()) {
        for(Col : 0..Grid.get(0).len()) {
            if(Get Cell(Grid, Row, Col) == "#") {
                let Neighbors = Count Neighbors(Grid, Row, Col, "#")
                if(Neighbors >= 3) {
                    Count = Count + 1
                }
            }
        }
    }
    Count
}

println(Solve Part 1(Input))
```

### With Maps (Frequency Counting Pattern)
```gaul
let Input = read_file("input.txt")

fn Solve(Input) {
    let Freq = [:]
    for(Line : Input.lines()) {
        for(Char : Line.trim().chars()) {
            Freq.set(Char, Freq.get_or(Char, 0) + 1)
        }
    }

    var Total = 0
    for(Key : Freq) {
        if(Freq.get(Key) > 1) {
            Total = Total + Freq.get(Key)
        }
    }
    Total
}

println(Solve(Input))
```

---

## Summary: Quick Reference Card

| Feature | Gaul Syntax |
|---------|-------------|
| Variable (immutable) | `let My Var = value` |
| Variable (mutable) | `var My Var = value` |
| Function | `fn My Func(Param) { body }` |
| Lambda | `fn(X) { X * 2 }` |
| If expression | `if(cond) { a } else { b }` |
| For each | `for(Item : Array) { }` |
| For range | `for(I : 0..10) { }` |
| While | `while(cond) { }` |
| And/Or/Not | `a && b`, `a \|\| b`, `!a` |
| Array access | `Arr.get(0)`, `Arr.set(0, val)` |
| Map literal | `["key": val, ...]`, `[:]` (empty) |
| Map access | `M.get("key")`, `M.set("key", val)` |
| Map check | `M.has("key")`, `M.len()`, `M.keys()` |
| For over map | `for(Key : My Map) { }` (iterates keys) |
| Fuzzy equal | `a ~= b` |
| Bitwise | `&`, `\|`, `^`, `<<`, `>>`, `~` (integer ops) |
| Map (array) | `Arr.map(fn(X) { ... })` |
| Filter | `Arr.filter(fn(X) { ... })` |
| Reduce | `Arr.reduce(init, fn(Acc, X) { ... })` |
| Self-ref lambda | `let F = fn(N) { F(N - 1) }` |
| Tail call opt. | Tail-position calls don't grow the stack |
| Multiline chain | `(Arr.map(...).filter(...))` (wrap in parens!) |
| Modulo | `N.mod(M)` or `N % M` |
| Min / Max | `min(A, B)`, `max(A, B)` |
| To string | `N.to_str()`, `true.to_str()` |
| Read file | `read_file("path")` |
| Print | `println(value)`, `print(value)` (no newline) |
